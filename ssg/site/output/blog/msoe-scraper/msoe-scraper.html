<!DOCTYPE html>
<html>
  <head>
    <title>
      How to Schedule for Classes at MSOE
    </title>
    <link href="/styles/style.css" rel="stylesheet">
    <link href="/styles/prism.css" rel="stylesheet">
    <link href="/styles/prism.css" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <base href="/blog/msoe-scraper/">
    <script>
    /*to prevent Firefox FOUC, this must be here*/
    let FF_FOUC_FIX;
    </script>
  </head>
  <body>
    <div class="container">
      <p>
        <a class="icon" href="https://github.com/xiugaze/msoe-open-seat">
        msoe-open-seat</a>
      </p>
      <p>
        Scheduling for new classes at MSOE can be somewhat confusing and
        stressful. In this article, I want to quickly share a few tips and
        tricks I’ve learned from my time here at school.
      </p>
      <h2>
        Scheduling
      </h2>
      <p>
        Right around week seven or eight, you’ll receive your scheduling time
        in <a href="https://my.msoe.edu">MyMSOE</a>.
      </p>
      <p>
        Sometimes, you’ll get a late scheduling time, which means you may not
        be able to get all of the classes you want. Unfortunately, you don’t
        really have a lot of control over this process. Your advisor might tell
        you that your registration time is dependent on how many credits you
        have, and that people are filtered into buckets based on their academic
        standing. However, the truth is that you’re probably scheduling late
        because of a loose cosmic ray that flipped your credit count from 60 to
        -127, or because Mercury is in retrograde, or because you forgot to
        sacrifice a goat to the registrar during week 6.
      </p>
      <p>
        If you’re really lucky, you’ll get an early scheduling date. This means
        that instead of having to compete with the rest of your class to land
        one of eighteen available seats for a class, you get to compete with
        half of your class to land one of eight seats that the registrar
        decided to open up.
      </p>
      <p>
        In either case, you might try to schedule and find that one of the
        classes you want is full. If this happens, don’t worry! You have a lot
        of options at this point:
      </p>
      <ul>
        <li>File a closed section request: This form asks a department to put
        you in a class that’s already full. This is a great way to practice
        coping with rejection emails from your internship applications!
        </li>
        <li>Schedule for an open section: You may have to put in some extra
        work to do well in a class with a more difficult professor, but hey, at
        the end of the day they’re all fair in the end, right?
        </li>
        <li>Wait for the section to open up: Seats can <em>always</em> be added
        to sections. In my experience, more seats tend to be added at times
        ending in a prime number, like 8:07 AM or 12:67 PM.
        </li>
      </ul>
      <h2>
        What happens if I don’t get my schedule?
      </h2>
      <p>
        If a class is a requirement in your academic track, then the school is
        required to give you a seat. In this case, a closed section request
        filed when all section are full will usually be approved without issue.
        This can be acutally be a good thing, because an 8:00 AM to 7:00 PM
        schedule is actually really good because it’s a realistic simulation of
        a real work day in industry!
      </p>
      <p>
        If you end up with a really bad schedule, learning new skills can help
        you cope with the reality you’re studying for finals already dreading
        the next term!
      </p>
      <p>
        As of right now, I’m not feeling all that good about my schedule for
        the fall. To distract us, let’s learn how to build a simple web scraper
        together!
      </p>
      <h2>
        web scraping
      </h2>
      <p>
        Web scraping is a way of programatically retrieving data or content
        from a website. We can use these techniques to automatically extract
        the static HTML data from a website, and with it, potentially database
        contents that gets served alongside the static website.
      </p>
      <p>
        For our little application, I’m going to just pick a <a href=
        "https://resources.msoe.edu/sched/courses/all">random website</a> that
        we can easily pull some data off of.
      </p>
      <figure>
        <a href="/images/scheduler.png"><img src="/images/scheduler.png" alt=
        "targets" title=""></a>
      </figure>
      <p>
        We’re going to have two major dependencies for our Python script:
        <code>request</code> from the standard library for our HTTP functions,
        and a library called <a href=
        "https://www.crummy.com/software/BeautifulSoup/bs4/doc/">Beautiful
        Soup</a> (<code>bs4</code>) for pulling elements from the DOM and
        packaging them as Python objects.
      </p>
      <pre><code class="language-python">import requests
from bs4 import BeautifulSoup

URL = "https://resources.msoe.edu/sched/courses/all"

page = requests.get(URL)
soup = BeautifulSoup(page.content, "html.parser")

</code></pre>
      <p>
        Our <code>page</code> object is a simple class that contains the data
        from an HTTP PUT, which is an HTTP primitive that sends data back in
        response to a GET request. You can read more about POST <a href=
        "https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT">here</a>.
        Specifically, this object is going to hold our HTML data in it’s
        <code>content</code> attribute, which we’re going to pass to the
        <code>BeautifulSoup()</code> constructor to instantiate the HTML
        document as an object tree. This constructor builds our DOM as a bunch
        of objects, and returns the root node which we’ll store in the
        <code>soup</code> variable.
      </p>
      <p>
        Now that we have a handle to our webpage, we can traverse through the
        tree to target a specific piece of data. For this example, we can see
        that the main content of the webpage is stored in a table,and using
        inspect inspect element confirms this structure:
      </p>
      <pre><code class="language-html">&lt;div class="table_wrapper"&gt;
  &lt;div class="table_wrapper_inner"&gt;
    &lt;table class="course-table"&gt;
        &lt;thead&gt;
        &lt;tr&gt;
            &lt;th style="width: 90px"&gt;Code&lt;/th&gt;
            &lt;th&gt;Title&lt;/th&gt;
            &lt;th&gt;Status&lt;/th&gt;
            &lt;th&gt;Instructor&lt;/th&gt;
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            &lt;tr&gt;
                &lt;td&gt;ACS  1130 001 &lt;/td&gt;
                &lt;td&gt;Introduction to Actuarial Science&lt;/td&gt;
                &lt;td&gt;Open&lt;/td&gt;
                &lt;td&gt;William M. Brummond&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;ACS  1530 001 &lt;/td&gt;
                &lt;td&gt;Financial Mathematics I&lt;/td&gt;
                &lt;td&gt;Open&lt;/td&gt;
                &lt;td&gt;. MA Staff&lt;/td&gt;
            &lt;/tr&gt;
            &lt;!-- ...etc --&gt;
</code></pre>
      <p>
        Okay, so here we can see that all of this data is stored in a
        <code>&lt;table&gt;</code> with <code>class ="course-table"</code> In
        HTML, the <code>class</code> attribute is <em>not</em> a unique
        identifier, meaning that there can be multiple tags that share the same
        class. However, this is the first occurence of this class in the
        document, so if there’s any more, we can just grab the first one.
      </p>
      <p>
        We can get a handle to the table using <code>b4f</code> method
        <code>find()</code>:
      </p>
      <pre><code class=
      "language-python">table = soup.find(class_="course-table").find("tbody")
</code></pre>
      <p>
        Here, we’re calling the <code>find()</code> method on our entire
        document, searching for the first element with the <code>class</code>
        attribute <code>"course-table"</code>. We’re then calling
        <code>find()</code> again on the <code>&lt;table&gt;</code> tag for the
        first <code>&lt;tbody&gt;</code> tag.
      </p>
      <p>
        Looking at our HTML document, we can see that it’s contains a bunch of
        <code>&lt;tr&gt;</code> (table row) tags, which in turn hold multiple
        <code>&lt;td&gt;</code> (table data) tags each. However, none of these
        elements specify any unique identifiers, like a <code>class</code> or
        <code>id</code> attribute.
      </p>
      <p>
        Let’s write a quick function to iterate through the
        <code>&lt;tbody&gt;</code> tag and search for the
        <code>&lt;tr&gt;</code> that contains a <code>&lt;td&gt;</code> with
        specific text:
      </p>
      <pre><code class="language-python">def find_td_in_tbody(tbody, string):
  for tr in tbody.find_all('tr'):
    for td in tr.find_all('td'):
      if string in td_tag.get_text():
        return td_tag
  return None

classcode = find_td_in_body(table, "ACS 1530 001")
</code></pre>
      <p>
        In this function, we iterate through each <code>&lt;tr&gt;</code> tag
        in the <code>&lt;tbody&gt;</code> tag. Within each of those, we iterate
        through each <code>&lt;td&gt;</code> tag, and check if it contains our
        search string. If it does, we return the <code>&lt;td&gt;</code>
        element, which corresponds to a cell in the table.
      </p>
      <p>
        Now that we and element in the row containing our search string, we can
        check if any of its siblings contain another search string.
      </p>
      <pre><code class="language-python">def find_in_sibling(tag, string):
  for sibling in tag.find_next_siblings():
    if string in sibling.get_text():
      return True
  return False
status = find_in_sibling(classcode, "Open")
</code></pre>
      <p>
        Putting all of this together, we can create a simple program that
        monitors for a state change in an HTML tag:
      </p>
      <pre><code class="language-python">import requests
from bs4 import BeautifulSoup

def find_td_in_tbody(tbody, string):
  for tr in tbody.find_all('tr'):
    for td in tr.find_all('td'):
      if string in td_tag.get_text():
        return td_tag

def find_in_sibling(tag, string):
  for sibling in tag.find_next_siblings():
    if string in sibling.get_text():
      return True
  return False

def main():
  URL = "https://resources.msoe.edu/sched/courses/all"
  class_name = "ACS 1130 001"

  page = requests.get(URL)
  soup = BeautifulSoup(page.content, "html.parser")

  table = soup.find(class_="course-table").find("tbody")

  class_element = find_td_in_body(table, class_name)
  open = find_in_sibling(class_element, "Open")

  status: str
  if(open):
    status = "Open"
  else:
    status = "Closed"

  print("Class " + classcode + " is currently " + status)
  

if __name__ == "__main__":
  main()

</code></pre>
      <p>
        Wow, look at that! We just automated the process of refreshing a page
        and seeing if something changed!
      </p>
      <h2>
        conclusion
      </h2>
      <p>
        take the power back
      </p>
    </div>
    <script src="/scripts/prism.js"></script>
  </body>
</html>
